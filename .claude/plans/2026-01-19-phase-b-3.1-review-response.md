# Phase B 3.1 レビュー対応計画

**作成日**: 2026-01-19
**目的**: Phase B executor 基盤（3.1）のレビュー指摘3点を計画に反映

---

## レビュー指摘事項

### 指摘1: NonceManager の `next()` を取引所制約起点で固定

**問題**: 現状の `counter.fetch_add(1)` では `server_time_offset_ms` が使われず、再起動/時刻ズレ時に取引所制約を満たせない

**修正内容**:
1. 取引所制約を明記（許容窓、高nonce100個集合）
2. 生成規則: `nonce = max(last_nonce + 1, approx_server_time_ms())`
3. `sync_with_server()` で counter も fast-forward
4. オフセット定義の明確化（`server - local`）

### 指摘2: NonceManager を Clock注入でテスト可能に

**問題**: `SystemTime::now()` 直呼びでテスト不安定

**修正内容**:
1. Clock trait 注入設計
2. テスト項目追加（単調増加、並行呼び出し、時刻逆行、sync fast-forward、ドリフト閾値）

### 指摘3: BatchScheduler のバッチ単位とバックプレッシャ確定

**問題**: バッチ単位が未確定だと nonce/署名/inflight の会計が設計できない

**修正内容**:
1. バッチ単位明確化（1 action = 複数 orders/cancels）
2. inflight上限との整合（enqueue拒否/待機/縮退）
3. キュー溢れ時の方針（優先順位、ドロップ/リトライ）

---

## 修正後の設計

### NonceManager（修正版）

```rust
/// 取引所制約
/// - 許容窓: (T-2days, T+1day) where T = ブロック時刻
/// - 高nonce上位100個: 最新100個のnonceのみ有効、古いものは無効化される
/// - 0起点禁止: 起動時に now_unix_ms へ fast-forward

/// Clock trait（テスト可能な時刻取得）
pub trait Clock: Send + Sync {
    fn now_ms(&self) -> u64;
}

pub struct SystemClock;
impl Clock for SystemClock {
    fn now_ms(&self) -> u64 {
        SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap()
            .as_millis() as u64
    }
}

pub struct NonceManager<C: Clock> {
    counter: AtomicU64,
    /// オフセット定義: server_time - local_time (正 = サーバが進んでいる)
    server_offset_ms: AtomicI64,
    last_sync_ms: AtomicU64,
    clock: C,
}

impl<C: Clock> NonceManager<C> {
    /// 起動時に now_unix_ms へ fast-forward（0起点禁止）
    pub fn new(clock: C) -> Self {
        let now_ms = clock.now_ms();
        Self {
            counter: AtomicU64::new(now_ms),
            server_offset_ms: AtomicI64::new(0),
            last_sync_ms: AtomicU64::new(now_ms),
            clock,
        }
    }

    /// サーバ時刻の近似値を計算
    /// approx_server_time = local_time + server_offset
    fn approx_server_time_ms(&self) -> u64 {
        let local = self.clock.now_ms();
        let offset = self.server_offset_ms.load(Ordering::SeqCst);
        if offset >= 0 {
            local + offset as u64
        } else {
            local.saturating_sub((-offset) as u64)
        }
    }

    /// nonce採番: max(last_nonce + 1, approx_server_time_ms())
    /// 「単調増加」と「時刻近傍」を両立
    pub fn next(&self) -> u64 {
        loop {
            let current = self.counter.load(Ordering::SeqCst);
            let server_approx = self.approx_server_time_ms();
            let next_nonce = current.saturating_add(1).max(server_approx);

            if self.counter
                .compare_exchange(current, next_nonce, Ordering::SeqCst, Ordering::SeqCst)
                .is_ok()
            {
                return next_nonce;
            }
        }
    }

    /// serverTime同期: counterもfast-forward
    pub fn sync_with_server(&self, server_time_ms: u64) -> Result<(), NonceError> {
        let local_ms = self.clock.now_ms();
        // offset = server - local (正 = サーバが進んでいる)
        let offset = server_time_ms as i64 - local_ms as i64;

        // ドリフト検知
        if offset.abs() > 5000 {
            return Err(NonceError::TimeDriftTooLarge(offset));
        }
        if offset.abs() > 2000 {
            tracing::warn!(offset_ms = offset, "Time drift detected (>2s)");
        }

        self.server_offset_ms.store(offset, Ordering::SeqCst);
        self.last_sync_ms.store(local_ms, Ordering::SeqCst);

        // counter も fast-forward（server_time_ms より低ければ追従）
        loop {
            let current = self.counter.load(Ordering::SeqCst);
            if current >= server_time_ms {
                break;
            }
            if self.counter
                .compare_exchange(current, server_time_ms, Ordering::SeqCst, Ordering::SeqCst)
                .is_ok()
            {
                tracing::info!(
                    old = current,
                    new = server_time_ms,
                    "Counter fast-forwarded on sync"
                );
                break;
            }
        }

        Ok(())
    }
}
```

### NonceManager テスト項目

| # | テスト | 期待動作 |
|---|--------|----------|
| 1 | 単調増加 | next() を連続呼出しで常に増加 |
| 2 | 並行呼び出し | 複数スレッドから呼び出しても重複なし |
| 3 | 時刻逆行 | MockClock で時刻を戻しても counter は減少しない |
| 4 | sync fast-forward | sync_with_server() で counter が server_time 以上になる |
| 5 | ドリフト 2s warn | offset 2001ms で warn ログ出力 |
| 6 | ドリフト 5s error | offset 5001ms で Err 返却 |
| 7 | 近傍維持 | next() が approx_server_time に追従 |

### BatchScheduler（修正版）

```rust
/// バッチ単位: 1 L1 action = 複数 orders/cancels
/// - 1つの action でも inflight post カウント 1 消費
/// - バッチ内に複数注文をまとめることで nonce/署名のオーバーヘッド削減

pub struct BatchScheduler {
    interval: Duration,                           // 100ms
    pending_orders: Mutex<VecDeque<PendingOrder>>,
    pending_cancels: Mutex<VecDeque<PendingCancel>>,
    inflight_tracker: Arc<InflightTracker>,
    config: BatchConfig,
}

pub struct BatchConfig {
    pub interval_ms: u64,           // 100
    pub max_orders_per_batch: usize, // 例: 50
    pub max_cancels_per_batch: usize, // 例: 50
    pub inflight_high_watermark: u32, // 例: 80（100の80%で縮退開始）
    pub queue_capacity: usize,       // 例: 1000
}

pub enum EnqueueResult {
    Queued,
    QueueFull,            // キュー溢れ → 拒否
    InflightLimitNear,    // inflight上限接近 → 縮退モード
}

impl BatchScheduler {
    /// 注文をキューに追加
    pub fn enqueue_order(&self, order: PendingOrder) -> EnqueueResult {
        let inflight = self.inflight_tracker.current();

        // inflight上限超過時は拒否
        if inflight >= 100 {
            return EnqueueResult::QueueFull;
        }

        // 高水位時は警告（縮退モード）
        if inflight >= self.config.inflight_high_watermark {
            tracing::warn!(inflight, "Inflight high watermark reached");
            return EnqueueResult::InflightLimitNear;
        }

        let mut queue = self.pending_orders.lock();
        if queue.len() >= self.config.queue_capacity {
            return EnqueueResult::QueueFull;
        }

        queue.push_back(order);
        EnqueueResult::Queued
    }

    /// キャンセルをキューに追加（優先度高）
    pub fn enqueue_cancel(&self, cancel: PendingCancel) -> EnqueueResult {
        // キャンセルは常に受け付け（優先度高）
        let mut queue = self.pending_cancels.lock();
        queue.push_back(cancel);
        EnqueueResult::Queued
    }

    /// 100ms周期でバッチ送信
    pub async fn tick(&self) -> Option<Batch> {
        // 1. キャンセルを優先的に収集
        let cancels = self.collect_cancels();

        // 2. 残りのinflight枠で注文を収集
        let inflight = self.inflight_tracker.current();
        let remaining_slots = 100_u32.saturating_sub(inflight);

        let orders = if remaining_slots > 0 && cancels.is_empty() {
            // キャンセルがなければ注文を処理
            self.collect_orders()
        } else if remaining_slots > 1 {
            // キャンセルがあっても残り枠があれば注文も処理
            self.collect_orders()
        } else {
            vec![]
        };

        if orders.is_empty() && cancels.is_empty() {
            return None;
        }

        Some(Batch { orders, cancels })
    }
}
```

### BatchScheduler 設計方針

| 項目 | 方針 |
|------|------|
| **バッチ単位** | 1 L1 action = 複数 orders/cancels（1 inflight消費） |
| **nonce粒度** | 1 action = 1 nonce（バッチ内の複数注文で共有） |
| **署名粒度** | 1 action = 1 署名 |
| **優先順位** | cancel > reduce-only > new order |
| **inflight上限** | 100、高水位(80)で縮退開始 |
| **キュー溢れ** | 新規注文は拒否、キャンセルは常に受付 |

---

## 修正対象ファイル

| ファイル | 修正内容 |
|---------|----------|
| `.claude/plans/2026-01-19-phase-b-executor-implementation.md` | セクション 3.1 を修正版で置換 |

---

## 検証方法

1. 計画修正後、レビュアーに再レビュー依頼
2. 実装時に以下を確認:
   - NonceManager ユニットテスト（7項目）がパス
   - BatchScheduler の inflight 制御が機能
   - Testnet で nonce エラーが発生しない
